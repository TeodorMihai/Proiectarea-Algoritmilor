Problema 1:
	
	Pentru fiecare string analizat, mai intai retin intr-un vector de freceventa aparitia fiecarui
	caracter. In functie de acest vector de frecventa determin daca este posibil sau nu sa 
	fac un palindrom din cuvantul dat. Daca am mai mult de un caracter care apare de un numar impar 
	de ori clar nu pot sa obtin un palindrom. Daca am un caracter care apare de un numar impar de ori
	dar lungimea este para, iarasi nu pot sa obtin un palindrom.
	Apoi ca sa fac din sir un palindrom procedez in felul urmator, folosind o strategie greedy:
	Iau prima litera din sirul de caractere. Daca este una care apare de un numar par de ori
	incerc sa gasesc "perechea ei", adica acelasi caracter dar care apare pe pozitia
	cea mai din dreapta din stringul care a ramas (adica care nu e palindrom). Avand in vedere
	ca trebuie pot forma un palindrom, tot timpul voi gasi un astfel de caracter. Dupa
	ce il gasesc il iau si il interschimb pana il pun pe pozitia dorita (simetrica fata
	de cea a caracterului initial). Contorizez cate interschimbari am facut.
	Daca este un caracter impar nu am garantia ca pot gasi un caracter identic cu el in cealalta 
	parte a sirului, asa ca incerc sa potrivesc din partea cealalta a sirului(unde nu am caracter 
	impar ca altfel s-ar fi potrivit din prima). Aplic acelasi procedeu doar ca caut de la inceput
	catre final acum. La fel dupa ce il gasesc il pun unde vreau si numar cate interschimbari am 
	facut. Astfel caracterul impar va fi schimbat spre centru si voi obtine un palindrom.

	Complexitate: parcurg jumate din sir, si pentru fiecare caracter mai parcurg 
				  de doua ori tot sirul, odata sa gasesc caracterul, si odata sa-l potrivesc.
				  adica O( (n / 2) * (2 * n)) = O(n^2)
Problema 2:
	
	Problema o rezolv folosind distanta levensthein (adica  tehnica de programare dinamica)
	Distanta levensthein practic ne zice cum putem transforma un sir in altul folosind un numar
	minim de operatii. Am adaptat problema astfel incat cand trebuie sa vad daca doua caractere sunt 
	egale ca sa pot sa formez sirul (i, j) din sirul ( i -1, j - 1) adaugand doar caracterul ultim, 
	si astfel un cost de 0.trebuie sa caut caracterul pe care vreau sa-l potrivesc sa zicem c printre 
	toate caracterele de pe coloana j a matricei date initial. (se pot citi cele nr cuvinte ca o 
	matrice ). Ca sa nu parcurg de fiecare data o intraga coloana intreaga retin printr-un hash
	pentru fiecare coloana ce elemente am. Astfel dimineasiunea elementelor fiind mica pot sa 
	aflu daca exista un element sau nu pe coloana instant (O(1)).
	In rest am aplicat clasic levensthein, am scris in cod mai multe detalii despre algoritm.

	Complexitate: complexitatea algorimtului levensthein adica O(n^2)